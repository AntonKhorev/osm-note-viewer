import {Tool, ToolElements, ToolFitMode, ToolCallbacks, makeMapIcon, makeNotesIcon} from './tools/base'
import {OverpassTurboTool, OverpassDirectTool} from './tools/overpass'
import {GpxTool, GeoJsonTool} from './tools/export'

import type {Note} from './data'
import {NoteMap} from './map'
import FigureDialog from './figure'
import CommentWriter from './comment-writer'
import {makeElement, makeLink, makeEscapeTag} from './util'

type InfoElements = Array<string|HTMLElement>
const p=(...ss: InfoElements)=>makeElement('p')()(...ss)
const em=(s: string)=>makeElement('em')()(s)
const dfn=(s: string)=>makeElement('dfn')()(s)
const ul=(...ss: InfoElements)=>makeElement('ul')()(...ss)
const li=(...ss: InfoElements)=>makeElement('li')()(...ss)

export {Tool, ToolFitMode, ToolCallbacks}

class AutozoomTool extends Tool {
	constructor() {super(
		'autozoom',
		`Automatic zoom`,
		`Pan and zoom the map to visible notes`
	)}
	getInfo() {return[p(
		`Pan and zoom the map to notes in the table. `,
		`Can be used as `,em(`zoom to data`),` for notes layer if `,dfn(`to all notes`),` is selected. `,
	),p(
		dfn(`To notes in table view`),` allows to track notes in the table that are currently visible on screen, panning the map as you scroll through the table. `,
		`This option is convenient to use when `,em(`Track between notes`),` map layer is enabled (and it is enabled by default). This way you can see the current sequence of notes from the table on the map, connected by a line in an order in which they appear in the table.`
	)]}
	getTool(callbacks: ToolCallbacks, map: NoteMap): ToolElements {
		const $fitModeSelect=document.createElement('select')
		$fitModeSelect.append(
			new Option('is disabled','none'),
			new Option('to notes in table view','inViewNotes'),
			new Option('to all notes','allNotes')
		)
		$fitModeSelect.onchange=()=>{
			if ($fitModeSelect.value=='allNotes') {
				callbacks.onFitModeChange(this,$fitModeSelect.value)
				map.fitNotes()
			} else if ($fitModeSelect.value=='inViewNotes') {
				callbacks.onFitModeChange(this,$fitModeSelect.value)
				map.fitNoteTrack()
			} else {
				callbacks.onFitModeChange(this,undefined)
			}
		}
		return [$fitModeSelect]
	}
}

class TimestampTool extends Tool {
	private $timestampInput=document.createElement('input')
	constructor() {super(
		'timestamp',
		`Timestamp for historic queries`
	)}
	getInfo() {return[p(
		`Allows to select a timestamp for use with `,em(`Overpass`),` and `,em(`Overpass turbo`),` commands. `,
		`You can either enter the timestamp in ISO format (or anything else that Overpass understands) manually here click on a date of/in a note comment. `,
		`If present, a `,makeLink(`date setting`,`https://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL#date`),` is added to Overpass queries. `,
		`The idea is to allow for examining the OSM data at the moment some note was opened/commented/closed to evaluate if this action was correct.`
	),p(
		`Timestamps inside note comments are usually generated by apps like `,makeLink(`MAPS.ME`,`https://wiki.openstreetmap.org/wiki/MAPS.ME`),` to indicate their OSM data version.`
	)]}
	getTool(callbacks: ToolCallbacks): ToolElements {
		// this.$timestampInput.type='datetime-local' // no standard datetime input for now because they're being difficult with UTC and 24-hour format.
		// this.$timestampInput.step='1'
		this.$timestampInput.type='text'
		this.$timestampInput.size=20
		this.$timestampInput.oninput=()=>{
			callbacks.onTimestampChange(this,this.$timestampInput.value)
		}
		const $clearButton=document.createElement('button')
		$clearButton.type='reset'
		$clearButton.textContent='Clear'
		const $form=makeElement('form')()(this.$timestampInput,` `,$clearButton)
		$form.onreset=()=>{
			callbacks.onTimestampChange(this,'')
		}
		return [$form]
	}
	onTimestampChange(timestamp: string): boolean {
		this.$timestampInput.value=timestamp
		return true
	}
}

class ParseTool extends Tool {
	constructor() {super(
		'parse',
		`Parse links`
	)}
	getInfo() {return[p(
		`Parse text as if it's a note comment and get its first active element. If such element exists, it's displayed as a link after →.`,
		`Currently detected active elements are: `,
	),ul(
		li(`links to images made in `,makeLink(`StreetComplete`,`https://wiki.openstreetmap.org/wiki/StreetComplete`)),
		li(`links to OSM notes (clicking the output link is not yet implemented)`),
		li(`links to OSM changesets`),
		li(`links to OSM elements`),
		li(`ISO-formatted timestamps`)
	),p(
		`May be useful for displaying an arbitrary OSM element in the map view. Paste the element URL and click the output link.`
	)]}
	getTool(callbacks: ToolCallbacks, map: NoteMap, figureDialog: FigureDialog): ToolElements {
		const commentWriter=new CommentWriter(
			map,figureDialog,
			()=>{}, // TODO ping note section
			(timestamp)=>callbacks.onTimestampChange(this,timestamp)
		)
		const $input=document.createElement('input')
		$input.type='text'
		$input.size=50
		$input.classList.add('complicated')
		const $parseButton=document.createElement('button')
		$parseButton.type='submit'
		$parseButton.textContent='Parse'
		const $clearButton=document.createElement('button')
		$clearButton.type='reset'
		$clearButton.textContent='Clear'
		const $output=document.createElement('code')
		$output.append(getFirstActiveElement([]))
		const $form=makeElement('form')()($input,` `,$parseButton,` `,$clearButton)
		$form.onsubmit=(ev)=>{
			ev.preventDefault()
			const [elements]=commentWriter.makeCommentElements($input.value)
			$output.replaceChildren(getFirstActiveElement(elements))
		}
		$form.onreset=()=>{
			$output.replaceChildren(getFirstActiveElement([]))
		}
		return [$form,` → `,$output]
		function getFirstActiveElement(elements: Array<string|HTMLAnchorElement|HTMLTimeElement>): string|HTMLElement {
			for (const element of elements) {
				if (element instanceof HTMLAnchorElement) {
					element.textContent=`link`
					return element
				} else if (element instanceof HTMLTimeElement) {
					element.textContent=`date`
					return element
				}
			}
			return `none`
		}
	}
}

class RcTool extends Tool {
	private selectedNotes: ReadonlyArray<Note> = []
	constructor() {super(
		'rc',
		`RC`,
		`JOSM (or another editor) Remote Control`
	)}
	getInfo() {return[p(
		`Load note/map data to an editor with `,
		makeLink(`remote control`,'https://wiki.openstreetmap.org/wiki/JOSM/RemoteControl'),
		`.`
	)]}
	getTool(callbacks: ToolCallbacks, map: NoteMap): ToolElements {
		const e=makeEscapeTag(encodeURIComponent)
		const $loadNotesButton=this.makeRequiringSelectedNotesButton()
		$loadNotesButton.append(`Load `,makeNotesIcon('selected'))
		$loadNotesButton.onclick=async()=>{
			for (const {id} of this.selectedNotes) {
				const noteUrl=e`https://www.openstreetmap.org/note/${id}`
				const rcUrl=e`http://127.0.0.1:8111/import?url=${noteUrl}`
				const success=await openRcUrl($loadNotesButton,rcUrl)
				if (!success) break
			}
		}
		const $loadMapButton=document.createElement('button')
		$loadMapButton.append(`Load `,makeMapIcon('area'))
		$loadMapButton.onclick=()=>{
			const bounds=map.bounds
			const rcUrl=e`http://127.0.0.1:8111/load_and_zoom`+
				`?left=${bounds.getWest()}&right=${bounds.getEast()}`+
				`&top=${bounds.getNorth()}&bottom=${bounds.getSouth()}`
			openRcUrl($loadMapButton,rcUrl)
		}
		return [$loadNotesButton,` `,$loadMapButton]
	}
	protected onSelectedNotesChangeWithoutHandlingButtons(selectedNotes: ReadonlyArray<Note>, selectedNoteUsers: ReadonlyMap<number,string>): boolean {
		this.selectedNotes=selectedNotes
		return true
	}
}

class IdTool extends Tool {
	constructor() {super(
		'id',
		`iD`
	)}
	getInfo() {return[p(
		`Follow your notes by zooming from one place to another in one `,makeLink(`iD editor`,'https://wiki.openstreetmap.org/wiki/ID'),` window. `,
		`It could be faster to do first here in note-viewer than in iD directly because note-viewer won't try to download more data during panning. `,
		`After zooming in note-viewer, click the `,em(`Open`),` button to open this location in iD. `,
		`When you go back to note-viewer, zoom to another place and click the `,em(`Open`),` button for the second time, the already opened iD instance zooms to that place. `,
		`Your edits are not lost between such zooms.`
	),p(
		`Technical details: this is an attempt to make something like `,em(`remote control`),` in iD editor. `,
		`Convincing iD to load notes has proven to be tricky. `,
		`Your best chance of seeing the selected notes is importing them as a `,em(`gpx`),` file. `,
		`See `,makeLink(`this diary post`,`https://www.openstreetmap.org/user/Anton%20Khorev/diary/398991`),` for further explanations.`,
	),p(
		`Zooming/panning is easier to do, and that's what is currently implemented. `,
		`It's not without quirks however. You'll notice that the iD window opened from here doesn't have the OSM website header. `,
		`This is because the editor is opened at `,makeLink(`/id`,`https://www.openstreetmap.org/id`),` url instead of `,makeLink(`/edit`,`https://www.openstreetmap.org/edit`),`. `,
		`It has to be done because otherwise iD won't listen to `,em(`#map`),` changes in the webpage location.`
	)]}
	getTool(callbacks: ToolCallbacks, map: NoteMap): ToolElements {
		// limited to what hashchange() lets you do here https://github.com/openstreetmap/iD/blob/develop/modules/behavior/hash.js
		// which is zooming/panning
		const $zoomButton=document.createElement('button')
		$zoomButton.append(`Open `,makeMapIcon('center'))
		$zoomButton.onclick=()=>{
			const e=makeEscapeTag(encodeURIComponent)
			const url=e`https://www.openstreetmap.org/id#map=${map.zoom}/${map.lat}/${map.lon}`
			open(url,'id')
		}
		return [$zoomButton]
	}
}

abstract class StreetViewTool extends Tool {
	getTool(callbacks: ToolCallbacks, map: NoteMap): ToolElements {
		const $viewButton=document.createElement('button')
		$viewButton.append(`Open `,makeMapIcon('center'))
		$viewButton.onclick=()=>{
			open(this.generateUrl(map),this.id)
		}
		return [$viewButton]
	}
	protected abstract generateUrl(map: NoteMap): string
}

class YandexPanoramasTool extends StreetViewTool {
	constructor() {super(
		'yandex-panoramas',
		`Y.Panoramas`,
		`Yandex.Panoramas (Яндекс.Панорамы)`
	)}
	getInfo() {return[p(
		`Open a map location in `,makeLink(`Yandex.Panoramas`,'https://wiki.openstreetmap.org/wiki/RU:%D0%A0%D0%BE%D1%81%D1%81%D0%B8%D1%8F/%D0%AF%D0%BD%D0%B4%D0%B5%D0%BA%D1%81.%D0%9F%D0%B0%D0%BD%D0%BE%D1%80%D0%B0%D0%BC%D1%8B'),` street view. `,
		`Could be useful to find out if an object mentioned in a note existed at a certain point of time. `,
		`Yandex.Panoramas have a year selector in the upper right corner. Use it to get a photo made close to the date of interest.`
	)]}
	protected generateUrl(map: NoteMap): string {
		const e=makeEscapeTag(encodeURIComponent)
		const coords=map.lon+','+map.lat
		return e`https://yandex.ru/maps/?ll=${coords}&panorama%5Bpoint%5D=${coords}&z=${map.zoom}` // 'll' is required if 'z' argument is present
	}
}

class MapillaryTool extends StreetViewTool {
	constructor() {super(
		'mapillary',
		`Mapillary`
	)}
	getInfo() {return[p(
		`Open a map location in `,makeLink(`Mapillary`,'https://wiki.openstreetmap.org/wiki/Mapillary'),`. `,
		`Not yet fully implemented. The idea is to jump straight to the best available photo, but in order to do that, Mapillary API has to be queried for available photos. That's impossible to do without an API key.`
	)]}
	protected generateUrl(map: NoteMap): string {
		const e=makeEscapeTag(encodeURIComponent)
		return e`https://www.mapillary.com/app/?lat=${map.lat}&lng=${map.lon}&z=${map.zoom}&focus=photo`
	}
}

class CountTool extends Tool {
	private $fetchedNoteCount=document.createElement('output')
	private $visibleNoteCount=document.createElement('output')
	private $selectedNoteCount=document.createElement('output')
	constructor() {super(
		'counts',
		`Note counts`
	)}
	getTool(): ToolElements {
		this.$fetchedNoteCount.textContent='0'
		this.$visibleNoteCount.textContent='0'
		this.$selectedNoteCount.textContent='0'
		return [
			this.$fetchedNoteCount,` fetched, `,
			this.$visibleNoteCount,` visible, `,
			this.$selectedNoteCount,` selected`
		]
	}
	onNoteCountsChange(nFetched: number, nVisible: number): boolean {
		this.$fetchedNoteCount.textContent=String(nFetched)
		this.$visibleNoteCount.textContent=String(nVisible)
		return true
	}
	protected onSelectedNotesChangeWithoutHandlingButtons(selectedNotes: ReadonlyArray<Note>, selectedNoteUsers: ReadonlyMap<number,string>): boolean {
		this.$selectedNoteCount.textContent=String(selectedNotes.length)
		return true
	}
}

class LegendTool extends Tool {
	constructor() {super(
		'legend',
		`Legend`,
		`What do icons in command panel mean`
	)}
	getTool(): ToolElements {
		return [
			makeMapIcon('center'),` = map center, `,makeMapIcon('area'),` = map area, `,makeNotesIcon('selected'),` = selected notes`
		]
	}
}

class SettingsTool extends Tool {
	constructor() {super(
		'settings',
		`⚙️`,
		`Settings`
	)}
	getTool(callbacks: ToolCallbacks): ToolElements {
		const $openAllButton=document.createElement('button')
		$openAllButton.textContent=`+ open all tools`
		$openAllButton.onclick=()=>callbacks.onToolOpenToggle(this,true)
		const $closeAllButton=document.createElement('button')
		$closeAllButton.textContent=`− close all tools`
		$closeAllButton.onclick=()=>callbacks.onToolOpenToggle(this,false)
		return [$openAllButton,` `,$closeAllButton]
	}
}

export const toolMakerSequence: Array<()=>Tool> = [
	()=>new AutozoomTool, ()=>new TimestampTool, ()=>new ParseTool,
	()=>new OverpassTurboTool, ()=>new OverpassDirectTool,
	()=>new RcTool, ()=>new IdTool,
	()=>new GpxTool, ()=>new GeoJsonTool,
	()=>new YandexPanoramasTool, ()=>new MapillaryTool,
	()=>new CountTool, ()=>new LegendTool, ()=>new SettingsTool
]

async function openRcUrl($button: HTMLButtonElement, rcUrl: string): Promise<boolean> {
	try {
		const response=await fetch(rcUrl)
		if (response.ok) {
			clearError()
			return true
		}
	} catch {}
	setError()
	return false
	function setError() {
		$button.classList.add('error')
		$button.title='Remote control command failed. Make sure you have an editor open and remote control enabled.'
	}
	function clearError() {
		$button.classList.remove('error')
		$button.title=''
	}
}
